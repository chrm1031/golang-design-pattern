# 生成に関するデザインパターン
## Factory Method
具象クラスを指定することなく、 プロダクトのオブジェクトを生成することが可能

## Abstract Factory
関連したオブジェクトの集りを、具象クラスを指定することなく生成することを可能とする

## Builder
複雑なオブジェクトを段階的に構築することを可能とする
目的とするプロダクトが複雑で、完成まで多くのステップが必要なときに使用する
**単一の巨大なコンストラクタ**を持つよりも、いくつかの構築メソッドを持つほうがシンプルである。

## Prototype
特定のクラスに結合することなく、 オブジェクトのクローン作成を可能とする
プロトタイプのクラス全部には、 共通するインターフェースが必要である
これにより具象クラスが不明であってもオブジェクトを複製することが可能となる

# 構造に関するデザインパターン
## Adapter
非互換なインターフェースのオブジェクト同士の稼働を可能とする
アダプターは2つのオブジェクト間のラッパーとして稼働する
一方のオブジェクトへの呼び出しを捕まえ、二つ目のオブジェクトが認識可能なデータ形式とインターフェースへ変換する

## Composite
オブジェクトを木のような構造に構成し、あたかも単一のおブジェクトであるかのように扱えるようにする

## Decorator
ある振る舞いを含む特別なラッパー・オブジェクトの中にオブジェクトを配置することで、 それらのオブジェクトに新しい振る舞いを付け加える

## Facade
複雑なクラスのシステム、ライブラリー、フレームワークに対して単純なインターフェースを提供する

## Bridge
巨大なクラスや密接に関連したクラスの集まりを、 抽象部分と実装部分という
二つの階層に分離し、 それぞれが独立して開発できるようにする

## Flyweight
複数のオブジェクト間で共通する部分を各自で持つ代わりに共有することによって、
利用可能な RAM により多くのオブジェクトを収められるようにする

## Proxy
他のオブジェクトの代理、 代用を提供する
プロキシーは元のオブジェクトへのアクセスを制御し、
元のオブジェクトへリクエストが行く前か後に別の何かを行うようにすることが可能

# 振る舞いに関するデザインパターン
## Command
リクエストを、 それに関するすべての情報を含む独立したオブジェクトに転換する。
この転換により
リクエストをメソッドの引数として渡したり、
リクエストの実行を遅らせたり、
待ち行列に入れたり、取り消し操作を行なうことが可能になる

## Chain of Responsibility
ハンドラーの連鎖に沿ってリクエストを渡すことができる
各ハンドラーはリクエストを受け取ると、リクエストを処理するか、連鎖内の次のハンドラーに渡すかを決める